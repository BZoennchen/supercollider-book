# Pattern

Using [UGens](sec-ugens) we can design synth, i.e., instruments, i.e., sound.
But having instruments is not enough, we also want to play them!
We want to create rhythms and texture.

As mentioned in [The Ecosystem](sec-ecosystem), we could use another Software such as [Sonic Pi](https://sonic-pi.net/), [TidalCycle](https://tidalcycles.org/) or [FoxDot](https://foxdot.org/) to do so.
However, [SuperCollider (SC)](https://supercollider.github.io/) offers its own amazing and powerful interface to compose a musical piece.
It uses so called [Pattern](https://doc.sccode.org/Classes/Pattern.html), [Streams](https://doc.sccode.org/Classes/Stream.html) and [Events](https://doc.sccode.org/Classes/Event.html).

I call this section Pattern because as we will see, we do not really care about ``Streams`` and ``Events`` if we understand the concept of ``Pattern``.

## The Instrument and its Artist

Philosophically speaking, the tools we use, influence how we think about the world.
Tools, like pen and paper, instruments, a hammer, programming languages or frameworks, and even our hands, act like interpreters.
They translate our thoughts into actions that change the physical world around us.

However, this interaction is not a one-way-street where we, the artist, enforce ideas on the instrument.
Instead, the instrument we use influences our ideas by limiting the space of possibilities.
In fact, we have no idea of any expressions before we interact with some interpreter, i.e., some tool/instrument.
The instrument defines the space of possibilities.
It makes up our imagination.
It might be even the other way around: the instrument is using us to express itself.

In my opinion, there is no clear optimal amount of limitations, i.e., space of possibilities.
Too much freedom can be a burden on the artist.
Without boundaries the language of the instrument can be to complicated.
If we can express everything, we become unable to express anything at all -- it can be hard to get started.
On the other hand, too strict limitations will lead to repetition.
If the space of possibilities is too small, the artist becomes superfluous.

Therefore, to find out what space of possibilities you are looking for, I highly recommend that you check out all available tools and if none suites your needs you may want to build your own! 
Building instrument to express ourselves is one of those wonderful acts a programmer can do!
Of course, you will always stay in some limited super-space of possibilities defined by the machine you are working on.
Our machines are able to compute anything that is Turing-computable which is, as far we know, anything that is computable in general.
However, we are limited by the computational time and space complexity of the problem we want to compute.

Now let us talk about the space of possibilities that **sclang** offers us.

## Pattern, Streams and Events

A [Stream](https://doc.sccode.org/Classes/Stream.html) is basically a series of elements that you can obtain in a **lazy** fashion.
It is very similar to an ``Array`` with the difference that it is **lazy**.
Laziness means that instead of holding all values of the ``Stream`` in the memory (like an ``Array`` does) the values are generated by a function when needed.
Therefore, a ``Stream`` can contain infinitely many values which is impossible for an ``Array``!
For example, we can define a function that gives us all integers.

```isc
~val = 0;
f = {~val = ~val + 1; ~val;};
f.();
```

If we evaluate the last line multiple times, we get 1, 2, 3, and so on.
This is basically an infinite stream of values.
We can use [FuncStream](https://doc.sccode.org/Classes/FuncStream.html) to create a ``Stream`` of integers.
Then we can call ``next`` on the ``Stream`` to get the next value of it.

```isc
(
~val = 0;
f = {~val = ~val + 1; ~val;};
x = FuncStream(f);
)
x.next(); // 1
x.next(); // 2
x.next(); // 3
```

If a ``Stream`` runs out of values, it returns ``nil``.
In **sclang** everything is an [Object](https://doc.sccode.org/Classes/Object.html) and the class ``Object`` defines ``next`` to return the object itself.
Therefore, every object can be viewed as a ``Stream``.
If it is a constant it streams itself.
Consequently, almost everything can be viewed as a ``Stream``.

```isc
5.next();  // 5
```

[Pattern](https://doc.sccode.org/Classes/Pattern.html) is an abstract class that is the base for the Patterns library. 
Together all pattern classes form a rich and concise score language for music.
``Patterns`` are the blueprint of ``Streams``.
Calling ``asStream`` on a ``Pattern`` transforms it into a ``Stream``.
As already mentioned, all simple objects respond to this interface, by returning themselves.
Consequently, most objects are ``Pattern`` that define a ``Stream`` that represents an infinite sequence of that object.

```{admonition} Pattern and Streams
:name: important-pattern-and-streams
:class: important
Simlar to classes and objects, ``Pattern`` are a blueprint for ``Streams``.
```

Let us look at a non-trivial example:

```isc
p = Pseq(list: [Prand((5..7)), Prand((1..4))], repeats: 2) * 10;
q = p.asStream();
q.next; // random number between 50 and 70
q.next; // random number between 10 and 40
q.next; // random number between 50 and 70
q.next; // random number between 10 and 40
q.next; // nil
```

``Pseq`` transforms an ``Array`` into a ``Pattern``. 
``Prand`` choses from an ``Array`` a random element.
In the above example, we combine both ``Pattern``.
``Pseq`` gets an ``Array`` consisting of two ``Prand``-``Pattern``.
By the parameter ``repeats: 2`` we configure ``Pseq`` go over ``list`` two times.

Why are ``Patterns`` useful?
Well ``Patterns`` can be combined and they can be manipulated by all regular math functions if they return numbers.
They are really powerful to build complex ``Streams``.
In the above example we multiply the ``Pseq``-``Pattern`` by 10 (which returns a ``BinaryOpStream``).

If we think in musical terms, a composition is a specific ``Pattern`` and a performance is a ``Stream`` of that ``Pattern``. 
Playing a piano can be seen as a ``Stream`` of specific [Events](https://doc.sccode.org/Classes/Event.html).
We press some keys, with some velocity, for some duration, then we might wait for some amount of time and press the next keys.

## Pbind - Modeling a Musician

[Pbind](https://doc.sccode.org/Classes/Pbind.html) is a ``Pattern`` of ``Events``. 
It models the playing of an instrument, i.e. the actual musician by a stream of discrete events.

```{admonition} Combining Streams
:name: hint-pbind
:class: hint
``Pbind`` combines several *value streams* into *one event stream*.
```

### Playing Events

We define a duration ``dur``, and the parameters of our instrument and the instrument itself, i.e., the synth.
A ``Pbind`` can then be played by calling ``play`` on it.
The method returns a [EventStreamPlayer](https://doc.sccode.org/Classes/EventStreamPlayer.html).

``Events`` extend [Environments](https://doc.sccode.org/Classes/Environment.html).
``Environments`` manage namespaces.
They are very similar to hash maps, hash tables, or Python dictionary.
For example, calling a function will create a new local function-``Environment``.
An ``Environment`` maps names to variables and functions.

```isc
(
var env = Environment.make({
    ~a = 100;
    ~b = 200;
    ~c = 300;
    ~add = {arg x, y; x + y;};
});
env.postln;
env[\a]; // 100
env[\add].(3,13); // 16
)
```

Here we define an environment with three variables ``a``, ``b``, ``c`` and a function ``add``.
``~a;`` is in fact an abbreviation for ``currentEnvironment.at(\a);`` and `` ~a = 100;`` for ``currentEnvironment.put(\a, 888);``.
As you can see we already worked with environments without knowing it.
We are not so much interested in ``Environments`` but ``Events`` and they can be defined using a far more compact syntax, i.e., we just use round brackets:

```isc
(
var event = (\dur: 1, \freq: 600);
event.play;
)
```

What is going on here?
We actually can hear a sound???
Well if you look at the print window, you can see all the predefined variables/symbols of the ``Environment``/``Event``.
Everything that we have to define to play a sound such as ``\amp``, ``\instrument``, ``\server`` is predefined.

The ``\instrument`` is a default instrument that is built-in into SuperCollider but we can use our own ``SynthDef``, i.e., synth.
To use all the nice parameters, our ``SynthDef`` has to use the correct arguments and we have to name them as intended.
For example, the frequency should be called ``freq``, if we want to be able to sustain the sound we should use a sustaining envelope with a gate argument called ``gate`` and the amplitude should be defined by ``amp``.

```isc
(
SynthDef(\beep, {
    arg freq = 600, amp = 0.2, gate = 1;
    var sig, env;
    env = EnvGen.kr(
        Env.asr(attackTime: 0.01, sustainLevel: 1.0, releaseTime: 0.1), 
        gate: gate, 
        doneAction: Done.freeSelf);
    sig = SinOsc.ar(freq!2) * env * amp;
    Out.ar(0, sig);
}).add;
)

(
var event = (\instrument: \beep, \dur: 0.2, \freq: 300);
event.play;
)
```

First we add a very simple synth then we play it for a duration of ``0.2`` beats per seconds.
If we look closely, we can observer that there is a ``sustain`` argument that is set to 80 percent of the duration, i.e. to ``0.16`` beats per seconds.
It is the time after the ``gate`` within our synth is triggered!
We can set ``sustain`` ourselves.

```isc
(
var event = (\instrument: \beep, \sustain: 0.1, \dur: 0.2, \freq: 300);
event.play;
)
```

This seems to make the ``dur`` argument irrelevant.
However, we need ``dur`` if we not only play one event but a ``Stream`` of events!
Let us have a look.

```isc
(
Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], inf),
    \dur, 0.4,
    \sustain, 0.1 
).play;
)
```

### Playing EventStreams

``Pbind`` is a special ``Pattern`` that generates a ``Stream`` that spits out ``Events``.
By using the ``play`` method on the ``Pbind`` pattern, we play all the events the event stream gives us.
In that case, ``dur`` determines the waiting time between two successive events.
Thereby, we do not play all events instantly but create a rhythm.

```{admonition} Difference between duration and sustain
:name: hint-overlapping-sound
:class: hint
The duration ``dur`` is the elapsed time after the next event is scheduled while ``sustain`` is the time after the ``gate`` of the synth is triggered. If the sound sustains longer than ``dur`` we get overlapping sounds.
```

For example:

```isc
(
p = Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], inf),
    \dur, 0.1,
    \sustain, 0.3
);
q = p.play;
)
q.stop;
```

We can call ``stop`` on the ``Stream`` (not the ``Pattern``!) to stop it (or we can hit ``CMD`` + ``.`` / ``Ctrl`` + ``.`` as always).

Since we combine multiple ``Streams`` we may want to influence one value stream by the other.
For example, we might want that the ``amp`` depends on the frequency such that we can reduce the amplitude for higher pitches.#
There are multiple was to do so.
One is by using one of the most powerfull ``Pattern``, that is [Pfunc](https://doc.sccode.org/Classes/Pfunc.html).

``Pfunc`` expects a function as argument and this function is called whenever the respective ``Stream`` generates its next value.
The argument of the ``next`` call is passed to the function.

```isc
(
var pattern = Pfunc({arg val; val*val;});
var square = pattern.asStream();
square.next(5);
)
```

``Pbind`` passes the whole event to this function.
Therefore, we can look inside the event, and use the information to compute our value.
In the following code snippet we print the ``amp`` so you can see the effect.

```isc
(
p = Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], inf),
    \dur, 0.25,
    \sustain, 0.3,
	\amp, Pfunc({arg event; min(1.0, event[\freq].linexp(100, 500, 1.0, 0.2)).postln;})
);
q = p.play;
)
```

``Pfunc`` can do a lot of other things and there is a pattern that is specifically designed for our case.
It is called [Pkey](https://doc.sccode.org/Classes/Pkey.html).
The following code creates exactly the same sound.

```isc
(
p = Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], inf),
    \dur, 0.25,
    \sustain, 0.3,
	\amp, Pkey(\freq).linexp(100, 500, 1.0, 0.2)
);
q = p.play;
)
```

The third way to do this, is to use a global variable.
However, this seems to be a really dirty method which I do not recommend.
I think, using ``Pkey`` is the cleanest way to do things.

### Cascading Pbinds

We can, of course, use multiple ``Pbinds``.

```isc
(
var intro, middle, outro;
intro = Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], 3),
    \dur, 0.25,
    \sustain, 0.3,
	\amp, Pkey(\freq).linexp(100, 500, 1.0, 0.2)
);

middle = Pbind(
    \instrument, \beep,
    \freq, Pseq([233, 321, 344], 3),
    \dur, 0.25,
    \sustain, 0.3,
	\amp, Pkey(\freq).linexp(100, 500, 1.0, 0.2)
);

outro = intro = Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], 3),
    \dur, 0.25,
    \sustain, 0.3,
    \amp, Pkey(\freq).linexp(100, 500, 1.0, 0.2)
);

p = Pseq(list: [intro, middle, outro], repeats: 2);
q = p.play;
)
```

What a masterpiece ;).
We can generate the same piece using only one ``Pbind``:

```isc
(
var intro, middle, outro;
p = Pbind(
    \instrument, \beep,
	\freq, Pseq([
		Pseq([440, 220, 330], 3), 
		Pseq([233, 321, 344], 3),
		Pseq([440, 220, 330], 3)
	], repeats: 2),
    \dur, 0.25,
    \sustain, 0.3,
    \amp, Pkey(\freq).linexp(100, 500, 1.0, 0.2)
);
q = p.play;
)
```

Later we will see that we can organize our piece by using multiple ``Pbind``.
But for now let's move on.

## Examples

There are many different ``Pattern``, I will only discuss some of them which I find most important.
In fact, the official [documentation of SuperCollider](https://doc.sccode.org/) is not always super helpful but the tutorial [Understanding Streams, Patterns and Events](https://doc.sccode.org/Tutorials/Streams-Patterns-Events1.html) is an excellent source to get started.

I use two ``SynthDefs`` for the following examples.
One simple beep generated by a sine wave and a percussive drum like synth.
TODO!

# Pattern

[UGens](sec-ugens) are the basic building blocks for our synth, i.e., instruments, i.e., sound.
But having instruments is not enough, we also want to play them!
We want to create rhythms, and texture and melodies.

As mentioned in [The Ecosystem](sec-ecosystem), there are other software packages such as [Sonic Pi](https://sonic-pi.net/), [TidalCycle](https://tidalcycles.org/) or [FoxDot](https://foxdot.org/) which are designed to play synths and samples.
However, [SuperCollider (SC)](https://supercollider.github.io/) offers its own amazing and powerful interface to compose a musical piece.
It uses so called [Pattern](https://doc.sccode.org/Classes/Pattern.html), [Streams](https://doc.sccode.org/Classes/Stream.html) and [Events](https://doc.sccode.org/Classes/Event.html).

I call this section Pattern because, as we will see, we do not really care about ``Streams`` and ``Events`` if we understand the concept of ``Pattern``.

## The Instrument and its Artist

In my opinion there is no clear separation between the world of ideas and the world of materials and tools.
Philosophically speaking, the tools we use, influence how we think about the world.
And our thoughts lead to new tools, new technologies.
Tools, like pen and paper, instruments, a hammer, programming languages or frameworks, and even our hands, act like interpreters.
They translate our thoughts into actions that change the physical world around us.

However, this interaction is not a one-way-street where we, the artist, enforce ideas onto the instrument.
Instead, the instrument influences our ideas by limiting our space of possibilities.
Before we think about the being of a hammer, we use it.
Furthermore, a hammer is always connected to other things, for example a nail or a wooden chair.
The instrument provides us with the means of expression. 
It defines the space of possibilities.
It makes up our imagination.
Maybe we can even go so far and say that it is in fact the instrument that uses us to express itself.

Consequently, there is no clear optimal amount of limitations, i.e., space of possibilities.
Changing the space can be a great source for inspiration.
Too much freedom can be a burden for the artist.
Without boundaries the language of the instrument can be too complicated.
If we can create everything, we become unable to express anything.
On the other hand, too strict limitations lead to repetition.
If the space of possibilities is too small, the artist becomes superfluous.

Therefore, to find out what space of possibilities you are looking for, I highly recommend that you check out all available tools and if none suites your needs you may want to build your own! 
Building instruments to express ourselves, is one of those wonderful acts a programmer can do!
Of course, we will always stay in some limited super-space of possibilities defined by the machine we are working on.
Our machines are able to compute anything that is *Turing-computable*, i.e., (up to this day) everything that we can compute in general
However, we are limited by time and space.
On the computer is translates to computational time and space complexities.

Now let us talk about the space of possibilities that **sclang** offers.

## Pattern, Streams and Events

A [Stream](https://doc.sccode.org/Classes/Stream.html) is basically a series of elements that you can obtain in a **lazy** fashion.
It is very similar to an ``Array`` with the difference that it is **lazy**.
Laziness means that instead of holding all values of the ``Stream`` in the memory (like an ``Array`` does) the values are generated by a function when needed.
Therefore, a ``Stream`` can contain infinitely many values which is impossible for an ``Array``!
For example, we can define a function that gives us all integers.

```isc
~val = 0;
f = {~val = ~val + 1; ~val;};
f.();
```

If we evaluate the last line multiple times, we get 1, 2, 3, and so on.
This is basically an infinite stream of values.
We can use [FuncStream](https://doc.sccode.org/Classes/FuncStream.html) to create a ``Stream`` of integers.
Then we can call ``next`` on the ``Stream`` to get the next value of it.

```isc
(
~val = 0;
f = {~val = ~val + 1; ~val;};
x = FuncStream(f);
)
x.next(); // 1
x.next(); // 2
x.next(); // 3
```

If a ``Stream`` runs out of values, it returns ``nil``.
In **sclang** everything is an [Object](https://doc.sccode.org/Classes/Object.html) and the class ``Object`` defines ``next`` to return the object itself.
Thus every object can be viewed as a ``Stream`` and most simply stream themselves.
Consequently, almost everything can be viewed as a ``Stream``.

[Pattern](https://doc.sccode.org/Classes/Pattern.html) is an abstract class that is the base for the Patterns library. 
These classes form a rich and concise score language for music.
``Patterns`` are the blueprint of ``Streams``.
Calling ``asStream`` on a ``Pattern`` transforms it into a ``Stream``.
All objects respond to this interface, most by returning themselves.
So most objects are ``Pattern`` that define streams that are an infinite sequence of the object and embed as singleton ``Streams`` of that object returned once.

Let us look at an example.

```isc
p = Pseq(list: [Prand((5..7)), Prand((1..4))], repeats: 2) * 10;
q = p.asStream();
q.next; // random number between 50 and 70
q.next; // random number between 10 and 40
q.next; // random number between 50 and 70
q.next; // random number between 10 and 40
q.next; // nil
```

``Pseq`` transforms an ``Array`` into a ``Pattern``. 
``Prand`` choses from an ``Array`` a random element.
In the above example, we combine both ``Pattern``.
``Pseq`` gets an ``Array`` consisting of two ``Prand``-``Pattern``.
By the parameter ``repeats: 2`` we configure ``Pseq`` to go over ``list`` two times.

Why are ``Patterns`` useful?
Well ``Patterns`` can be combined and they can be manipulated by all regular math functions if they return numbers.
They are really powerful to build complex ``Streams``.
In the above example we multiply the ``Pseq``-``Pattern`` by 10 (which returns a ``BinaryOpStream``).

If we think in musical terms, a composition is a specific ``Pattern`` and a performance is a ``Stream`` of that ``Pattern``. 
Playing a piano can be seen as a ``Stream`` of specific [Events](https://doc.sccode.org/Classes/Event.html).
We press some keys, with some velocity, for some duration, then we might wait for some amount of time and press the next keys.

[Pbind](https://doc.sccode.org/Classes/Pbind.html) is a ``Pattern`` of ``Events``. 
It models this process by discrete events.
We define a duration ``dur``, and the parameters of our instrument and the instrument itself, i.e., the synth.
A ``Pbind`` can then be played by calling ``play`` on it.
The method returns an [EventStreamPlayer](https://doc.sccode.org/Classes/EventStreamPlayer.html).

``Events`` extend [Environments](https://doc.sccode.org/Classes/Environment.html).
``Environments`` manage namespaces.
They are very similar to hash maps, hash tables, or a Python dictionary.
For example, calling a function will create a new local function-``Environment``.
``Environments`` map names to variables and functions.

```isc
(
var env = Environment.make({
    ~a = 100;
    ~b = 200;
    ~c = 300;
    ~add = {arg x, y; x + y;};
});
env.postln;
env[\a]; // 100
env[\add].(3,13); // 16
)
```

Here we define an ``Environment`` with three variables ``a``, ``b``, ``c`` and a function ``add``.
``~a`` is in fact an abbreviation for ``currentEnvironment.at(\a)`` and `` ~a = 100`` for ``currentEnvironment.put(\a, 888)``.
As you can see we already worked with ``Environments`` without knowing them.
We are not so much interested in ``Environments`` but ``Events`` and they can be defined using a far more compact syntax, i.e., we just use round brackets:

```isc
(
var event = (\dur: 1, \freq: 600);
event.play;
)
```

What is going on here?
We actually can hear a sound???
Well if you look at the print window, you can see all the predefined variables/symbols of the ``Environment``/``Event``.
Everything that we have to define to play a sound such as ``\amp``, ``\instrument``, ``\server`` is predefined.

The ``\instrument`` is a default instrument that is built into SuperCollider but we can use our own ``SynthDef``, i.e., synth.
To use all the nice predefined parameters, our ``SynthDef`` has to use the correct arguments and we have to name them as intended.
For example, the frequency should be called ``freq``, if we want to be able to sustain the sound we should use a sustaining envelope with a gate argument called ``gate`` and the amplitude should be defined by ``amp``.

```isc
(
SynthDef(\beep, {
    arg freq = 600, amp = 0.2, gate = 1;
    var sig, env;
    env = EnvGen.kr(
        Env.asr(attackTime: 0.01, sustainLevel: 1.0, releaseTime: 0.1), 
        gate: gate, 
        doneAction: Done.freeSelf);
    sig = SinOsc.ar(freq!2) * env * amp;
    Out.ar(0, sig);
}).add;
)

(
var event = (\instrument: \beep, \dur: 0.2, \freq: 300);
event.play;
)
```

First we add a very simple synth, then we play it for a duration of ``0.2`` beats per seconds (bps).
If we look closely, we can observer that there is a ``sustain`` argument that is set to 80 percent of the duration, i.e. to ``0.16`` beats per seconds.
It is the time after the ``gate`` within our synth is triggered!
We can change this default behavior by setting our own ``sustain`` value.

```isc
(
var event = (\instrument: \beep, \sustain: 0.1, \dur: 0.2, \freq: 300);
event.play;
)
```

This seems to make the ``dur`` argument irrelevant.
However, we need ``dur`` if we not only play one event but a ``Stream`` of events!
Let us have a look.

```isc
(
Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], inf),
    \dur, 0.4,
    \sustain, 0.1 
).play;
)
```

``Pbind`` is a special ``Pattern`` that generates a ``Stream`` that spits out ``Events``.
By using the ``play`` method on the ``Pbind`` pattern, we play all the events the event stream gives us.
In that case, ``dur`` determines the waiting time between two successive events.
Thereby, we do not play all events instantly but create a rhythm.
**Note** that if the sound sustains longer than ``dur`` we get overlapping sounds, i.e., [legato](sec-legato).
For example:

```isc
(
p = Pbind(
    \instrument, \beep,
    \freq, Pseq([440, 220, 330], inf),
    \dur, 0.1,
    \sustain, 0.3
);
q = p.play;
)
q.stop;
```

We can call ``stop`` on the ``Stream`` (not the ``Pattern``!) to stop it (or we can hit ``CMD`` + ``.`` / ``Ctrl`` + ``.`` as always).

## Examples

There are many different ``Pattern``, I will only discuss some of them which I find most important.
In fact, the official [documentation of SuperCollider](https://doc.sccode.org/) is not always super helpful but the tutorial [Understanding Streams, Patterns and Events](https://doc.sccode.org/Tutorials/Streams-Patterns-Events1.html) is an excellent source to get started.

I use two ``SynthDefs`` for the following examples.
One simple beep generated by a sine wave and a percussive drum like synth.
TODO!
